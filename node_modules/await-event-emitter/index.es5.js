'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var _regeneratorRuntime = _interopDefault(require('babel-runtime/regenerator'));
var _asyncToGenerator = _interopDefault(require('babel-runtime/helpers/asyncToGenerator'));
var _typeof = _interopDefault(require('babel-runtime/helpers/typeof'));

var emit = function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(type) {
    var listeners,
        _len,
        args,
        _key,
        i,
        event,
        _args = arguments;

    return _regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            assertType(type);
            listeners = this.listeners(type);

            if (!(listeners && listeners.length)) {
              _context.next = 14;
              break;
            }

            for (_len = _args.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = _args[_key];
            }

            i = 0;

          case 5:
            if (!(i < listeners.length)) {
              _context.next = 13;
              break;
            }

            event = listeners[i];
            _context.next = 9;
            return event.apply(undefined, args);

          case 9:
            if (this._events[type][i][TYPE_KEYNAME] === 'once') {
              this.removeListener(type, event);
            }

          case 10:
            i++;
            _context.next = 5;
            break;

          case 13:
            return _context.abrupt('return', true);

          case 14:
            return _context.abrupt('return', false);

          case 15:
          case 'end':
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function emit(_x) {
    return _ref3.apply(this, arguments);
  };
}();

/**
 * @file: AwaitEventEmitter
 * @author: Cuttle Cong
 * @date: 2017/11/1
 * @description:
 */
var TYPE_KEYNAME = typeof Symbol === 'function' ? Symbol('--[[await-event-emitter]]--') : '--[[await-event-emitter]]--';

function assertType(type) {
  if (typeof type !== 'string' && (typeof type === 'undefined' ? 'undefined' : _typeof(type)) !== 'symbol') {
    throw new TypeError('type is not type of string or symbol!');
  }
}

function assertFn(fn) {
  if (typeof fn !== 'function') {
    throw new TypeError('fn is not type of Function!');
  }
}

function alwaysListener(fn) {
  var _ref;

  return _ref = {}, _ref[TYPE_KEYNAME] = 'always', _ref.fn = fn, _ref;
}
function onceListener(fn) {
  var _ref2;

  return _ref2 = {}, _ref2[TYPE_KEYNAME] = 'once', _ref2.fn = fn, _ref2;
}

function AwaitEventEmitter() {
  this._events = {};
}

function on(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].push(alwaysListener(fn));
  return this;
}

function prepend(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].unshift(alwaysListener(fn));
  return this;
}

function prependOnce(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].unshift(onceListener(fn));
  return this;
}

function listeners(type) {
  return (this._events[type] || []).map(function (x) {
    return x.fn;
  });
}

function once(type, fn) {
  assertType(type);
  assertFn(fn);
  this._events[type] = this._events[type] || [];
  this._events[type].push(onceListener(fn));
  return this;
}

function removeListener(type, nullOrFn) {
  assertType(type);

  var listeners = this.listeners(type);
  if (typeof nullOrFn === 'function') {
    var index = void 0,
        found = false;
    while ((index = listeners.indexOf(nullOrFn)) >= 0) {
      listeners.splice(index, 1);
      this._events[type].splice(index, 1);
      found = true;
    }
    return found;
  } else {
    return delete this._events[type];
  }
}

AwaitEventEmitter.prototype.on = AwaitEventEmitter.prototype.addListener = on;
AwaitEventEmitter.prototype.once = once;
AwaitEventEmitter.prototype.prependListener = prepend;
AwaitEventEmitter.prototype.prependOnceListener = prependOnce;
AwaitEventEmitter.prototype.off = AwaitEventEmitter.prototype.removeListener = removeListener;
AwaitEventEmitter.prototype.emit = emit;
AwaitEventEmitter.prototype.listeners = listeners;

if (typeof module !== 'undefined') {
  module.exports = AwaitEventEmitter;
}
